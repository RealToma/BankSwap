{"version":3,"sources":["views/Nft/market/index.tsx","state/nftMarket/hooks.ts"],"names":["Home","lazy","NftProfile","Collection","Collections","Market","account","useWeb3React","initializationState","useGetNFTInitializationState","useFetchCollections","NFTMarketInitializationState","INITIALIZED","exact","path","nftsBaseUrl","to","toLowerCase","dispatch","useAppDispatch","useEffect","fetchCollections","useFetchCollection","collectionAddress","fetchCollection","useFetchByBunnyIdAndUpdate","bunnyId","useSelector","state","nftMarket","data","loadingState","latestPancakeBunniesUpdateAt","isUpdatingPancakeBunnies","existingBunniesInState","useGetAllBunniesByBunnyId","existingTokensWithBunnyId","map","nft","tokenId","allPancakeBunnies","useNftsFromCollection","pancakeBunniesAddress","allExistingPBTokenIds","firstBunny","length","existingMetadata","useMemo","name","description","collection","collectionName","image","fetchMorePancakeBunnies","orderDirection","fetchNewPBAndUpdateExisting","useLoadingState","useGetCollections","collections","useGetCollection","checksummedCollectionAddress","isAddress","nfts","filter","attributes","value","marketData","isTradable","useUserNfts","user","useGetNftFilters","collectionFilter","filters","activeFilters","useGetNftFilterLoadingState","NftFilterLoadingState","IDLE","useGetNftOrdering","ordering","field","direction","useGetNftShowOnlyOnSale","showOnlyOnSale","useGetNftActivityFilters","activityFilters","typeFilters"],"mappings":"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","file":"static/js/34.e804e734.chunk.js","sourcesContent":["import React, { lazy } from 'react'\r\nimport { Redirect, Route } from 'react-router-dom'\r\nimport { useWeb3React } from '@web3-react/core'\r\nimport { useFetchCollections, useGetNFTInitializationState } from 'state/nftMarket/hooks'\r\nimport PageLoader from 'components/Loader/PageLoader'\r\nimport { NFTMarketInitializationState } from 'state/nftMarket/types'\r\nimport { nftsBaseUrl } from './constants'\r\n\r\nconst Home = lazy(() => import('./Home'))\r\nconst NftProfile = lazy(() => import('./Profile'))\r\nconst Collection = lazy(() => import('./Collection'))\r\nconst Collections = lazy(() => import('./Collections'))\r\n\r\nconst Market = () => {\r\n  const { account } = useWeb3React()\r\n  const initializationState = useGetNFTInitializationState()\r\n\r\n  useFetchCollections()\r\n\r\n  if (initializationState !== NFTMarketInitializationState.INITIALIZED) {\r\n    return <PageLoader />\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <Route exact path={nftsBaseUrl}>\r\n        <Home />\r\n      </Route>\r\n      <Route exact path={`${nftsBaseUrl}/collections`}>\r\n        <Collections />\r\n      </Route>\r\n      <Route path={`${nftsBaseUrl}/collections/:collectionAddress`}>\r\n        <Collection />\r\n      </Route>\r\n      <Route path={`${nftsBaseUrl}/profile/:accountAddress?`}>\r\n        <NftProfile />\r\n      </Route>\r\n      <Route exact path={`${nftsBaseUrl}/profile`}>\r\n        <Redirect to={`${nftsBaseUrl}/profile/${account?.toLowerCase() || ''}`} />\r\n      </Route>\r\n    </>\r\n  )\r\n}\r\n\r\nexport default Market\r\n","import { useEffect, useMemo } from 'react'\r\nimport { useSelector } from 'react-redux'\r\nimport { useAppDispatch } from 'state'\r\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\r\nimport { isAddress } from 'utils'\r\nimport { fetchCollection, fetchCollections, fetchNewPBAndUpdateExisting } from './reducer'\r\nimport { State } from '../types'\r\nimport { NftActivityFilter, NftFilter, NftFilterLoadingState, NftToken, UserNftsState } from './types'\r\n\r\nconst MAX_GEN0_ID = 4\r\n\r\nexport const useFetchCollections = () => {\r\n  const dispatch = useAppDispatch()\r\n  useEffect(() => {\r\n    dispatch(fetchCollections())\r\n  }, [dispatch])\r\n}\r\n\r\nexport const useFetchCollection = (collectionAddress: string) => {\r\n  const dispatch = useAppDispatch()\r\n  useEffect(() => {\r\n    dispatch(fetchCollection(collectionAddress))\r\n  }, [dispatch, collectionAddress])\r\n}\r\n\r\n// Returns a function that fetches more NFTs for specified bunny id\r\n// as well as updating existing PB NFTs in state\r\n// Note: PancakeBunny specific\r\nexport const useFetchByBunnyIdAndUpdate = (bunnyId: string) => {\r\n  const dispatch = useAppDispatch()\r\n\r\n  const { latestPancakeBunniesUpdateAt, isUpdatingPancakeBunnies } = useSelector(\r\n    (state: State) => state.nftMarket.data.loadingState,\r\n  )\r\n\r\n  // Extra guard in case market data shifts\r\n  // we don't wanna fetch same tokens multiple times\r\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId)\r\n  const existingTokensWithBunnyId = existingBunniesInState ? existingBunniesInState.map((nft) => nft.tokenId) : []\r\n\r\n  const allPancakeBunnies = useNftsFromCollection(pancakeBunniesAddress)\r\n  const allExistingPBTokenIds = allPancakeBunnies ? allPancakeBunnies.map((nft) => nft.tokenId) : []\r\n\r\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null\r\n\r\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\r\n  const existingMetadata = useMemo(() => {\r\n    return firstBunny\r\n      ? {\r\n          name: firstBunny.name,\r\n          description: firstBunny.description,\r\n          collection: { name: firstBunny.collectionName },\r\n          image: firstBunny.image,\r\n        }\r\n      : null\r\n  }, [firstBunny])\r\n\r\n  // This fetches more bunnies when called\r\n  const fetchMorePancakeBunnies = (orderDirection: 'asc' | 'desc') => {\r\n    dispatch(\r\n      fetchNewPBAndUpdateExisting({\r\n        bunnyId,\r\n        existingTokensWithBunnyId,\r\n        allExistingPBTokenIds,\r\n        existingMetadata,\r\n        orderDirection,\r\n      }),\r\n    )\r\n  }\r\n\r\n  return { isUpdatingPancakeBunnies, latestPancakeBunniesUpdateAt, fetchMorePancakeBunnies }\r\n}\r\n\r\nexport const useLoadingState = () => {\r\n  return useSelector((state: State) => state.nftMarket.data.loadingState)\r\n}\r\n\r\nexport const useGetCollections = () => {\r\n  return useSelector((state: State) => state.nftMarket.data.collections)\r\n}\r\n\r\nexport const useGetCollection = (collectionAddress: string) => {\r\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\r\n  const collections = useGetCollections()\r\n  return collections[checksummedCollectionAddress]\r\n}\r\n\r\nexport const useNftsFromCollection = (collectionAddress: string) => {\r\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\r\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\r\n  return nfts\r\n}\r\n\r\nexport const useGetAllBunniesByBunnyId = (bunnyId: string) => {\r\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[pancakeBunniesAddress])\r\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\r\n}\r\n\r\nexport const useGetNFTInitializationState = () => {\r\n  return useSelector((state: State) => state.nftMarket.initializationState)\r\n}\r\n\r\nexport const useUserNfts = (): UserNftsState => {\r\n  return useSelector((state: State) => state.nftMarket.data.user)\r\n}\r\n\r\nexport const useHasGen0Nfts = (): boolean => {\r\n  const userNfts = useSelector((state: State) => state.nftMarket.data.user)\r\n  return userNfts.nfts.some((nft) => nft.attributes && Number(nft.attributes[0]?.value) <= MAX_GEN0_ID)\r\n}\r\n\r\nexport const useGetNftFilters = (collectionAddress: string) => {\r\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\r\n  return collectionFilter ? collectionFilter.activeFilters : {}\r\n}\r\n\r\nexport const useGetNftFilterLoadingState = (collectionAddress: string) => {\r\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\r\n  return collectionFilter ? collectionFilter.loadingState : NftFilterLoadingState.IDLE\r\n}\r\n\r\nexport const useGetNftOrdering = (collectionAddress: string) => {\r\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\r\n  return collectionFilter ? collectionFilter.ordering : { field: 'currentAskPrice', direction: 'asc' as 'asc' | 'desc' }\r\n}\r\n\r\nexport const useGetNftShowOnlyOnSale = (collectionAddress: string) => {\r\n  const collectionFilter: NftFilter = useSelector((state: State) => state.nftMarket.data.filters[collectionAddress])\r\n  return collectionFilter ? collectionFilter.showOnlyOnSale : true\r\n}\r\n\r\nexport const useGetNftActivityFilters = (collectionAddress: string) => {\r\n  const collectionFilter: NftActivityFilter = useSelector(\r\n    (state: State) => state.nftMarket.data.activityFilters[collectionAddress],\r\n  )\r\n  return collectionFilter || { typeFilters: [] }\r\n}\r\n"],"sourceRoot":""}